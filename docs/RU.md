# Документация

* [Первая программа](#Первая-программа)
* [Переменные](#Переменные-и-типы-данных)
* [Nullable типы](#Nullable-типы)
* [Операции сравнения](#операции-сравнения)
* [Условные конструкции](#условные-конструкции)


# Первая программа
Точкой входа в программу является функция
`main`. Все, что находится внутри нее
будет выполнятся при запуске программы.

Сперва давайте поздороваемся с миром 
при помощи функции `print` или
`println`.

````scala
def main {
    println("Hello World");
}
````

Если функция не принимает аргументов,
то скобки писать необязательно, 
поэтому такая запись эквивалентна:

````scala
def main(){
    println("Hello World");
}
````


# Переменные и типы данных

Создать переменную можно при помощи
ключевого слова `var`. 
После этого указывается имя переменной,
а после равно значение, которая она будет
хранить.
````scala
def main(){
    var test = 10;
    println(test);
}
````
Ожидаемо, что в консоли мы увидим `10`.
Когда тип явно не указывается, компилятор
его определяет сам, и в данном случае
тип будет `byte`.

Через двоеточие можно указывать тип
переменной, например:
````scala
def main(){
    var test : String = 10;
    println(test);
}
````
Данный код вызовет ошибку, так как тип 
String не может хранить число, он нужен
для хранения строк.

````scala
def main(){
    var test : String = "Hello World";
    println(test);
}
````
Данный код уже будет валидным, и в 
консоли мы увидим Hello World.

В ixion'e есть следующие типы:


# Nullable типы

Переменные, которые не являются 
примитивными могут хранить значение
`null`. В Ixion'e есть специальный 
синтаксис для таких переменных.
Например `String` - это не примитивный тип,
а значит хранить `null` он может.

Но вот проблема, если мы напишем такой
код:
````scala
def main(){
    var test : String;
    println(test);
}
````

То мы увидим ошибку:
````
[Ixion Exception]
│> [2:14] in file "test.ix" ['test']:
│> Cannot default initialize variable of type 'java.lang.String'
````

Она говорит о том, что переменной
не было присвоено дефолтное значение.
До этого мы всегда присваивали значение
переменной с типом String, но сейчас
мы этого не сделали, а значит в теории
она должна хранить `null`.

Чтобы дать переменной эту возможность,
изменим нашу конструкцию следующим
образом:
````scala
def main(){
    var test : String?;
    println(test);
}
````
После названия типа появился знак `?`,
теперь наша переменная хранит `null`, 
а значит именно это она и выведет в консоль.

# Операции сравнения

При сравнении возвращаемое значение
имеет тип `boolean`.

Возвращает true, если оба операнда равны:
`x == y (равно)`

Возвращает true, если оба операнда не равны:
`x != y (не равно)`

Возвращает true, если первый операнд больше второго:
`x > y (больше)`

Возвращает true, если первый операнд меньше второго:
`x < y (меньше)`

Возвращает true, если первый операнд больше или равен второму:
`x <= y (больше или равно)`

Возвращает true, если первый операнд меньше или равен второму:
`x >= y (меньше или равно)`

Пример использования:
````scala
def main {
    var x = 2;
    var y = 3;
    println(x == y);
}
````
В консоли мы увидим `false`, так как
2 не равно 3.


# Условные конструкции
Условия проверяют что-либо, и если это верно, то выполняют какой-либо код.

Простое условие состоит из одного `if`.

```scala
def main {
    if (true) {
        print("true");
    }
}
```

Все условные операторы:

* `if` - *если...*
* `else if` - *в другом случае, если...*
* `else` - *если ни одно из прошлых условий не выполнилось...*

```scala
def main {
    var x = 10;
    if (false) {
        print(1);
    
    } else if (x == 1) {
        print(2);
    
    } else if (x == 10) {
        print(3);
    
    } else {
        print(4);
    }
}
```

Вышеуказанный код выведет 3.
Первое условие не выполниться, потому-что оно false.
Второе условие не выполниться, так как x не равен 1.
Третье условие *выполнится*, так как x равен 10.
else не выполниться, так как было выполнено третье условие.


# Массивы
### Это один из сложных типов данных, в нём мы можем хранить сразу несколько значений.
#### Создание массива с указанием количества элементов
Указывать тип массива обязательно:
```scala
def main {
    var arr = new int[5];
    println(arr[1]);
}
```
Тут мы создали новый массив с типом int, в котором будет 10 элементов.

Первый элемент массива стоит по индексу *0*, так что если мы хотим вывести элемент массива с индексом *1*, то он будет вторым по порядку.
Однако в коде мы создаем массив с *5* ячейками, а значит он выглядит так: `[0, 0, 0, 0, 0]`. Поэтому при выводе `array[1]` мы получим *0*,
так же как было бы с любым другим элементом массива.

#### Создание массива с заранее известными элементами
```scala
def main(){

    var names = new String[] {
            "Artyom",
            "Alexandr",
            "Danya"
    };

}
```


